// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER MANAGEMENT MODELS
// ============================================

model User {
  id         Int     @id @default(autoincrement())
  email      String  @unique
  password   String?
  name       String
  picture    String?
  role       String  @default("DEVELOPER") // ADMIN, TESTER, DEVELOPER, GUEST
  isVerified Boolean @default(false)
  isActive   Boolean @default(true)

  // Account security
  verificationToken        String?
  verificationTokenExpiry  DateTime?
  failedLoginAttempts      Int       @default(0)
  lockedUntil              DateTime?
  lastLoginAt              DateTime?
  passwordResetToken       String?
  passwordResetTokenExpiry DateTime?
  passwordHistory          String[]  @default([]) // Array of hashed passwords for history
  tokenVersion             Int       @default(0) // For invalidating tokens on logout

  // Timestamps
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  // Relations
  projects           Project[]
  projectAllocations ProjectUserAllocation[]
  createdTestCases   TestCase[]              @relation("CreatedBy")
  assignedTestCases  TestCase[]              @relation("AssignedTo")
  ownedTestCases     TestCase[]              @relation("OwnedBy")
  modifiedTestCases  TestCase[]              @relation("LastModifiedBy")
  deletedTestCases   TestCase[]              @relation("DeletedBy")

  testRuns        TestRun[]       @relation("ExecutedBy")
  createdTestRuns TestRun[]       @relation("CreatedBy")
  testExecutions  TestExecution[]

  reportedBugs Bug[] @relation("ReportedBy")
  assignedBugs Bug[] @relation("AssignedTo")
  verifiedBugs Bug[] @relation("VerifiedBy")

  bugComments  BugComment[]
  auditLogs    AuditLog[]
  activityLogs UserActivityLog[]
  sessions     UserSession[]

  channelMembers  ChannelMember[]
  createdChannels ChannelMessage[] @relation("ChannelMessages")
  channelsCreated Channel[]        @relation("ChannelsCreatedBy")
  notifications   Notification[]
  apiKeys         ApiKey[]

  createdMilestones  Milestone[] @relation("CreatedBy")
  assignedMilestones Milestone[] @relation("AssignedTo")

  createdTestSuites  TestSuite[] @relation("CreatedBy")
  assignedTestSuites TestSuite[] @relation("AssignedTo")

  createdTestPlans  TestPlan[] @relation("CreatedBy")
  executedTestPlans TestPlan[] @relation("ExecutedBy")

  oauthIntegrations OAuthIntegration[]

  // Chat enhancements
  messageMentions MessageMention[] @relation("MessageMentions")
  messageReactions MessageReaction[] @relation("MessageReactions")
  pinnedMessages  PinnedMessage[] @relation("PinnedMessages")

  // Direct Messages
  directMessagesSent DirectMessage[] @relation("DirectMessagesSent")
  directMessagesReceived DirectMessage[] @relation("DirectMessagesReceived")
  directMessageReactions DirectMessageReaction[] @relation("DirectMessageReactions")

  // Admin controls - Mute functionality
  isMuted Boolean @default(false) // Is user currently muted
  mutedUntil DateTime? // When mute expires
  muteReason String? // Admin reason for mute
  mutedBy Int? // Admin ID who muted this user

  // Messages deleted by this admin
  deletedMessages ChannelMessage[] @relation("DeletedBy")

  // Channels locked/disabled by this admin
  lockedChannels Channel[] @relation("LockedBy")
  disabledChannels Channel[] @relation("DisabledBy")

  // Audit logs created by this admin
  auditLogEntries ChatAuditLog[] @relation("AuditLogAdmin")

  @@index([email])
  @@index([role])
  @@index([createdAt])
}

model ProjectUserAllocation {
  id          Int      @id @default(autoincrement())
  projectId   Int
  userId      Int
  projectRole String   @default("TESTER") // Project-specific role
  isActive    Boolean  @default(true)
  allocatedAt DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([projectId, userId])
  @@index([projectId])
  @@index([userId])
}

model UserActivityLog {
  id           Int      @id @default(autoincrement())
  userId       Int
  action       String
  resourceType String?
  resourceId   Int?
  description  String?
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@index([action])
}

model UserSession {
  id               Int       @id @default(autoincrement())
  userId           Int
  refreshTokenHash String    @unique
  ipAddress        String?
  userAgent        String?
  deviceLabel      String?
  createdAt        DateTime  @default(now())
  lastUsedAt       DateTime?
  rotatedAt        DateTime?
  revokedAt        DateTime?
  expiresAt        DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@index([revokedAt])
}

model AuditLog {
  id           Int      @id @default(autoincrement())
  userId       Int
  action       String // TESTCASE_CREATED, BUG_UPDATED, etc.
  resourceType String // TESTCASE, BUG, PROJECT, etc.
  resourceId   Int?
  resourceName String?
  projectId    Int?
  description  String?
  oldValues    String? // JSON stringified
  newValues    String? // JSON stringified
  timestamp    DateTime @default(now())
  ipAddress    String?
  userAgent    String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([action])
  @@index([resourceType])
  @@index([timestamp])
}

model OAuthIntegration {
  id         Int      @id @default(autoincrement())
  userId     Int
  provider   String // GOOGLE, GITHUB
  providerId String // User ID from OAuth provider
  email      String?
  metadata   Json? // Additional provider data
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerId])
  @@index([userId])
  @@index([provider])
  @@index([createdAt])
}

// ============================================
// PROJECT MODELS
// ============================================

model Project {
  id          Int       @id @default(autoincrement())
  name        String
  description String?
  key         String    @unique // Project key for bug numbering (e.g., PROJ)
  ownerId     Int
  status      String    @default("ACTIVE") // ACTIVE, ARCHIVED, INACTIVE
  isPublic    Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  owner User @relation(fields: [ownerId], references: [id], onDelete: Restrict)

  userAllocations ProjectUserAllocation[]
  testCases       TestCase[]
  testRuns        TestRun[]
  testSuites      TestSuite[]
  testPlans       TestPlan[]
  milestones      Milestone[]
  bugs            Bug[]
  customFields    CustomField[]
  environments    ProjectEnvironment[]
  webhooks        Webhook[]
  apiKeys         ApiKey[]

  @@index([ownerId])
  @@index([status])
}

model ProjectEnvironment {
  id          Int      @id @default(autoincrement())
  projectId   Int
  name        String
  description String?
  isActive    Boolean  @default(true)
  order       Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([projectId, name])
  @@index([projectId])
  @@index([isActive])
}

// ============================================
// TEST CASE MODELS
// ============================================

model TestCase {
  id                       Int      @id @default(autoincrement())
  projectId                Int
  name                     String
  description              String?
  preconditions            String?
  testData                 String?
  environment              String?
  type                     String   @default("FUNCTIONAL") // FUNCTIONAL, PERFORMANCE, SECURITY, USABILITY
  priority                 String   @default("P2") // P0, P1, P2, P3, P4
  severity                 String   @default("MINOR") // CRITICAL, MAJOR, MINOR, TRIVIAL
  status                   String   @default("DRAFT") // DRAFT, READY, IN_PROGRESS, COMPLETED, DEPRECATED
  estimatedDurationMinutes Int?
  moduleArea               String?
  tags                     String[] @default([])

  // Relationships
  assignedToId   Int?
  ownedById      Int?
  createdBy      Int
  lastModifiedBy Int
  deletedBy      Int?

  // Soft delete
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project    Project           @relation(fields: [projectId], references: [id], onDelete: Cascade)
  steps      TestCaseStep[]
  versions   TestCaseVersion[]
  executions TestExecution[]   @relation("TestCaseToExecution")
  bugs       Bug[]             @relation("TestCaseToBug")

  creator      User  @relation("CreatedBy", fields: [createdBy], references: [id], onDelete: Restrict)
  assignedTo   User? @relation("AssignedTo", fields: [assignedToId], references: [id], onDelete: SetNull)
  owner        User? @relation("OwnedBy", fields: [ownedById], references: [id], onDelete: SetNull)
  lastModifier User  @relation("LastModifiedBy", fields: [lastModifiedBy], references: [id])
  deleter      User? @relation("DeletedBy", fields: [deletedBy], references: [id], onDelete: SetNull)

  suites      TestSuiteTestCase[]
  milestone   Milestone?          @relation(fields: [milestoneId], references: [id])
  milestoneId Int?

  @@index([projectId])
  @@index([status])
  @@index([priority])
  @@index([isDeleted])
  @@index([createdAt])
}

model TestCaseStep {
  id             Int      @id @default(autoincrement())
  testCaseId     Int
  stepNumber     Int
  action         String
  expectedResult String
  notes          String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  testCase TestCase @relation(fields: [testCaseId], references: [id], onDelete: Cascade)

  @@index([testCaseId])
}

model TestCaseVersion {
  id            Int      @id @default(autoincrement())
  testCaseId    Int
  versionNumber Int
  name          String
  description   String?
  preconditions String?
  testData      String?
  environment   String?
  type          String
  priority      String
  severity      String
  status        String
  createdAt     DateTime @default(now())

  testCase TestCase @relation(fields: [testCaseId], references: [id], onDelete: Cascade)

  @@unique([testCaseId, versionNumber])
  @@index([testCaseId])
}

model TestCaseTemplate {
  id            Int      @id @default(autoincrement())
  projectId     Int?
  name          String
  description   String?
  type          String   @default("FUNCTIONAL")
  priority      String   @default("P2")
  severity      String   @default("MINOR")
  preconditions String?
  testData      String?
  environment   String?
  tags          String[] @default([])
  isPublic      Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([projectId])
}

// ============================================
// TEST SUITE MODELS
// ============================================

model TestSuite {
  id            Int       @id @default(autoincrement())
  projectId     Int
  name          String
  description   String?
  parentSuiteId Int?
  priority      String    @default("P2")
  status        String    @default("ACTIVE")
  createdBy     Int
  assignedToId  Int?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  deletedAt     DateTime?
  isDeleted     Boolean   @default(false)

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  creator User    @relation("CreatedBy", fields: [createdBy], references: [id])

  assignedTo User? @relation("AssignedTo", fields: [assignedToId], references: [id], onDelete: SetNull)

  parentSuite TestSuite?  @relation("SuiteHierarchy", fields: [parentSuiteId], references: [id], onDelete: SetNull)
  childSuites TestSuite[] @relation("SuiteHierarchy")

  testCases TestSuiteTestCase[]
  runs      TestSuiteRun[]

  @@index([projectId])
  @@index([isDeleted])
}

model TestSuiteTestCase {
  id         Int @id @default(autoincrement())
  suiteId    Int
  testCaseId Int
  order      Int @default(0)

  suite    TestSuite @relation(fields: [suiteId], references: [id], onDelete: Cascade)
  testCase TestCase  @relation(fields: [testCaseId], references: [id], onDelete: Cascade)

  @@unique([suiteId, testCaseId])
  @@index([suiteId])
  @@index([testCaseId])
}

// ============================================
// TEST RUN & EXECUTION MODELS
// ============================================

model TestRun {
  id             Int     @id @default(autoincrement())
  projectId      Int
  name           String
  description    String?
  environment    String?
  buildVersion   String?
  status         String  @default("PLANNED") // PLANNED, IN_PROGRESS, COMPLETED, CANCELLED
  totalTestCases Int     @default(0)
  passedCount    Int     @default(0)
  failedCount    Int     @default(0)
  blockedCount   Int     @default(0)
  skippedCount   Int     @default(0)

  executedBy  Int
  createdBy   Int
  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  project  Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  executor User    @relation("ExecutedBy", fields: [executedBy], references: [id])
  creator  User    @relation("CreatedBy", fields: [createdBy], references: [id])

  executions TestExecution[]

  @@index([projectId])
  @@index([status])
}

model TestExecution {
  id                    Int     @id @default(autoincrement())
  testRunId             Int
  testCaseId            Int
  status                String  @default("BLOCKED") // BLOCKED, READY, PASSED, FAILED, SKIPPED, NOT_RUN
  actualResult          String?
  actualDurationSeconds Int?

  userId      Int
  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  testRun  TestRun  @relation(fields: [testRunId], references: [id], onDelete: Cascade)
  testCase TestCase @relation("TestCaseToExecution", fields: [testCaseId], references: [id], onDelete: Cascade)
  executor User     @relation(fields: [userId], references: [id], onDelete: SetNull)

  steps    TestExecutionStep[]
  evidence TestExecutionEvidence[]
  bugs     Bug[]                   @relation("ExecutionToBug")

  @@index([testRunId])
  @@index([testCaseId])
  @@index([status])
}

model TestExecutionStep {
  id           Int      @id @default(autoincrement())
  executionId  Int
  stepNumber   Int
  status       String   @default("BLOCKED") // PASSED, FAILED, SKIPPED, BLOCKED
  actualResult String?
  notes        String?
  createdAt    DateTime @default(now())

  execution TestExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)

  @@index([executionId])
}

model TestExecutionEvidence {
  id          Int      @id @default(autoincrement())
  executionId Int
  filename    String
  url         String
  mimeType    String?
  size        Int?
  type        String   @default("SCREENSHOT") // SCREENSHOT, ATTACHMENT, VIDEO, LOG
  createdAt   DateTime @default(now())

  execution TestExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)

  @@index([executionId])
}

// ============================================
// TEST PLAN MODELS
// ============================================

model TestPlan {
  id              Int     @id @default(autoincrement())
  projectId       Int
  name            String
  description     String?
  scope           String? // Scope of the test plan
  status          String  @default("DRAFT") // DRAFT, READY, IN_PROGRESS, COMPLETED
  testCaseIds     Int[]   @default([]) // Array of test case IDs in this plan
  plannedDuration Int? // Planned duration in minutes
  plannerNotes    String? // Notes from the planner

  createdBy  Int
  executedBy Int?

  startDate DateTime?
  endDate   DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  project  Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  creator  User    @relation("CreatedBy", fields: [createdBy], references: [id])
  executor User?   @relation("ExecutedBy", fields: [executedBy], references: [id], onDelete: SetNull)

  @@index([projectId])
  @@index([status])
}

model TestSuiteRun {
  id             Int     @id @default(autoincrement())
  suiteId        Int
  projectId      Int
  name           String
  environment    String?
  buildVersion   String?
  status         String  @default("PLANNED")
  totalTestCases Int     @default(0)
  passedCount    Int     @default(0)
  failedCount    Int     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  suite TestSuite @relation(fields: [suiteId], references: [id], onDelete: Cascade)

  @@index([suiteId])
  @@index([projectId])
}

// ============================================
// BUG/DEFECT MODELS
// ============================================

model Bug {
  id              Int     @id @default(autoincrement())
  projectId       Int
  bugNumber       String  @unique // e.g., PROJ-001
  title           String
  description     String
  environment     String?
  affectedVersion String?
  reproducibility String  @default("SOMETIMES") // ALWAYS, OFTEN, SOMETIMES, RARELY, CANNOT_REPRODUCE

  status   String @default("OPEN") // OPEN, IN_PROGRESS, RESOLVED, VERIFIED, CLOSED, REOPEN
  priority String @default("P3") // P0, P1, P2, P3
  severity String @default("MINOR") // CRITICAL, MAJOR, MINOR, TRIVIAL

  reportedBy Int
  assigneeId Int?
  verifiedBy Int?

  testCaseId  Int?
  executionId Int?

  stepsToReproduce String?
  actualBehavior   String?
  expectedBehavior String?

  fixDocumentation  String?
  fixStrategy       String?
  rootCauseAnalysis String?
  rootCauseCategory String?
  fixedInCommitHash String?
  fixBranchName     String?
  codeReviewUrl     String?
  actualFixHours    Float?
  targetFixVersion  String?
  fixedInVersion    String?

  resolvedAt DateTime?
  verifiedAt DateTime?

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  closedAt  DateTime?

  project  Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  reporter User    @relation("ReportedBy", fields: [reportedBy], references: [id])
  assignee User?   @relation("AssignedTo", fields: [assigneeId], references: [id], onDelete: SetNull)
  verifier User?   @relation("VerifiedBy", fields: [verifiedBy], references: [id], onDelete: SetNull)

  testCase  TestCase?      @relation("TestCaseToBug", fields: [testCaseId], references: [id], onDelete: SetNull)
  execution TestExecution? @relation("ExecutionToBug", fields: [executionId], references: [id], onDelete: SetNull)

  comments    BugComment[]
  milestone   Milestone?   @relation(fields: [milestoneId], references: [id])
  milestoneId Int?

  retestRequests BugRetestRequest[]

  @@index([projectId])
  @@index([status])
  @@index([priority])
  @@index([severity])
}

model BugCounter {
  id         Int @id @default(autoincrement())
  projectId  Int @unique
  nextNumber Int @default(1)

  @@index([projectId])
}

model BugComment {
  id        Int      @id @default(autoincrement())
  bugId     Int
  userId    Int
  comment   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bug  Bug  @relation(fields: [bugId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([bugId])
  @@index([userId])
}

model BugRetestRequest {
  id        Int      @id @default(autoincrement())
  bugId     Int
  reason    String?
  status    String   @default("PENDING") // PENDING, APPROVED, REJECTED
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bug Bug @relation(fields: [bugId], references: [id], onDelete: Cascade)

  @@index([bugId])
}

// ============================================
// MILESTONE MODELS
// ============================================

model Milestone {
  id          Int       @id @default(autoincrement())
  projectId   Int
  name        String
  description String?
  startDate   DateTime?
  dueDate     DateTime?
  status      String    @default("PLANNED") // PLANNED, IN_PROGRESS, COMPLETED, ON_HOLD, CANCELLED

  createdBy    Int
  assignedToId Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project    Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  creator    User    @relation("CreatedBy", fields: [createdBy], references: [id])
  assignedTo User?   @relation("AssignedTo", fields: [assignedToId], references: [id], onDelete: SetNull)

  testCases TestCase[]
  bugs      Bug[]

  @@index([projectId])
  @@index([status])
}

// ============================================
// NOTIFICATION & COLLABORATION MODELS
// ============================================

model Notification {
  id            Int     @id @default(autoincrement())
  userId        Int
  type          String // BUG_ASSIGNED, TESTCASE_ASSIGNED, etc.
  title         String
  message       String
  resourceType  String? // BUG, TESTCASE, EXECUTION, etc.
  resourceId    Int?
  relatedUserId Int?

  isRead    Boolean   @default(false)
  readAt    DateTime?
  createdAt DateTime  @default(now())
  expiresAt DateTime? // Notification expiration

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
  @@index([expiresAt])
}

model Channel {
  id              Int      @id @default(autoincrement())
  name            String   @unique
  description     String?
  type            String   @default("GROUP") // GROUP, DIRECT
  channelType     String   @default("general") // general, role_based, project
  isPrivate       Boolean  @default(false)
  isSystemChannel Boolean  @default(false)
  allowedRoles    String[]  @default([]) // ADMIN, TESTER, DEVELOPER - for role-based channels
  projectName     String?   // For project-based channels
  archived        Boolean   @default(false)
  createdById     Int?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Admin controls - Lock and Disable
  isLocked Boolean @default(false) // Channel is locked, non-admins cannot send messages
  lockedById Int? // Admin ID who locked this channel
  lockedAt DateTime? // When channel was locked

  isDisabled Boolean @default(false) // Chat disabled, non-admins cannot access
  disabledById Int? // Admin ID who disabled chat
  disabledAt DateTime? // When chat was disabled

  createdBy User?            @relation("ChannelsCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  lockedBy User?             @relation("LockedBy", fields: [lockedById], references: [id], onDelete: SetNull)
  disabledBy User?           @relation("DisabledBy", fields: [disabledById], references: [id], onDelete: SetNull)
  members   ChannelMember[]
  messages  ChannelMessage[]
  pinnedMessages PinnedMessage[]

  @@index([isSystemChannel])
  @@index([type])
  @@index([channelType])
  @@index([archived])
}

model ChannelMember {
  id        Int      @id @default(autoincrement())
  channelId Int
  userId    Int
  joinedAt  DateTime @default(now())

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([channelId, userId])
  @@index([channelId])
  @@index([userId])
}

model ChannelMessage {
  id              Int      @id @default(autoincrement())
  channelId       Int
  userId          Int
  message         String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // JSON reaction summary for quick lookups
  reactionsSnapshot Json?

  // Pin metadata (for direct access without join)
  isPinned   Boolean   @default(false)
  pinnedById Int?
  pinnedAt   DateTime?

  // Admin controls - Soft delete
  isDeleted Boolean @default(false) // Message is soft deleted
  deletedById Int? // Admin ID who deleted this message
  deletedAt DateTime? // When message was deleted

  channel         Channel               @relation(fields: [channelId], references: [id], onDelete: Cascade)
  sender          User                  @relation("ChannelMessages", fields: [userId], references: [id], onDelete: Cascade)
  deletedBy       User?                 @relation("DeletedBy", fields: [deletedById], references: [id], onDelete: SetNull)
  
  // Mentions in this message
  mentions        MessageMention[]
  
  // Reactions to this message
  reactions       MessageReaction[]
  
  // Replies to this message
  replies         MessageReply[]        @relation("RepliedToMessage")
  
  // If this is a reply, the original message
  replyToId       Int?
  replyTo         MessageReply[]        @relation("ReplyFromMessage")
  
  // Pinned message reference
  pinnedMessage   PinnedMessage?

  @@index([channelId])
  @@index([userId])
  @@index([createdAt])
}

// ============================================
// CHAT ENHANCEMENTS
// ============================================

model MessageMention {
  id        Int      @id @default(autoincrement())
  messageId Int
  mentionedUserId Int
  createdAt DateTime @default(now())

  message ChannelMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  mentionedUser User @relation("MessageMentions", fields: [mentionedUserId], references: [id], onDelete: Cascade)

  @@unique([messageId, mentionedUserId])
  @@index([messageId])
  @@index([mentionedUserId])
}

model MessageReaction {
  id        Int      @id @default(autoincrement())
  messageId Int
  userId    Int
  emoji     String   // üëç üëÄ ‚úÖ ‚ùó etc
  createdAt DateTime @default(now())

  message ChannelMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation("MessageReactions", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
}

model MessageReply {
  id              Int      @id @default(autoincrement())
  messageId       Int      // The reply message itself
  replyToId       Int      // The original message being replied to
  createdAt       DateTime @default(now())

  message   ChannelMessage @relation("RepliedToMessage", fields: [messageId], references: [id], onDelete: Cascade)
  replyTo   ChannelMessage @relation("ReplyFromMessage", fields: [replyToId], references: [id], onDelete: Cascade)

  @@unique([messageId])
  @@index([messageId])
  @@index([replyToId])
}

model PinnedMessage {
  id        Int      @id @default(autoincrement())
  channelId Int
  messageId Int      @unique
  pinnedBy  Int
  pinnedAt  DateTime @default(now())

  channel   Channel         @relation(fields: [channelId], references: [id], onDelete: Cascade)
  message   ChannelMessage  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  pinnedByUser User         @relation("PinnedMessages", fields: [pinnedBy], references: [id], onDelete: Cascade)

  @@unique([channelId, messageId])
  @@index([channelId])
  @@index([pinnedAt])
}

// ============================================
// DIRECT MESSAGING
// ============================================

model DirectMessage {
  id          Int      @id @default(autoincrement())
  senderId    Int
  recipientId Int
  message     String
  isRead      Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  sender    User @relation("DirectMessagesSent", fields: [senderId], references: [id], onDelete: Cascade)
  recipient User @relation("DirectMessagesReceived", fields: [recipientId], references: [id], onDelete: Cascade)

  // Reactions on DMs
  reactions DirectMessageReaction[]

  // Replies to DMs
  replies DirectMessageReply[] @relation("RepliedToMessage")

  // If this is a reply, the original message
  replyToId Int?
  replyTo DirectMessageReply[] @relation("ReplyFromMessage")

  @@index([senderId])
  @@index([recipientId])
  @@index([createdAt])
  @@index([isRead])
}

model DirectMessageReaction {
  id        Int      @id @default(autoincrement())
  messageId Int
  userId    Int
  emoji     String
  createdAt DateTime @default(now())

  message DirectMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User         @relation("DirectMessageReactions", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
}

model DirectMessageReply {
  id        Int      @id @default(autoincrement())
  messageId Int      // The reply message itself
  replyToId Int      // The original message being replied to
  createdAt DateTime @default(now())

  message DirectMessage @relation("RepliedToMessage", fields: [messageId], references: [id], onDelete: Cascade)
  replyTo DirectMessage @relation("ReplyFromMessage", fields: [replyToId], references: [id], onDelete: Cascade)

  @@unique([messageId])
  @@index([messageId])
  @@index([replyToId])
}

// ============================================
// API & INTEGRATION MODELS
// ============================================

model ApiKey {
  id         Int       @id @default(autoincrement())
  projectId  Int
  name       String
  keyHash    String    @unique
  isActive   Boolean   @default(true)
  rateLimit  Int       @default(1000)
  lastUsedAt DateTime?
  createdBy  Int
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  expiresAt  DateTime?

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  creator User    @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([isActive])
}

model Webhook {
  id        Int      @id @default(autoincrement())
  projectId Int
  url       String
  event     String // BUG_CREATED, TEST_COMPLETED, etc.
  isActive  Boolean  @default(true)
  secret    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([event])
}

model WebhookLog {
  id             Int      @id @default(autoincrement())
  webhookId      Int
  event          String
  payload        String? // JSON stringified
  responseStatus Int?
  responseBody   String?
  error          String?
  createdAt      DateTime @default(now())

  @@index([webhookId])
  @@index([createdAt])
}

// ============================================
// SEARCH & CUSTOM FIELD MODELS
// ============================================

model SearchIndex {
  id           Int      @id @default(autoincrement())
  projectId    Int
  resourceType String // TESTCASE, BUG, EXECUTION
  resourceId   Int
  title        String
  description  String?
  searchText   String? // Concatenated searchable text
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([resourceType, resourceId])
  @@index([projectId])
  @@index([resourceType])
}

model CustomField {
  id         Int      @id @default(autoincrement())
  projectId  Int
  name       String
  fieldType  String // TEXT, NUMBER, SELECT, DATE, CHECKBOX
  options    String[] @default([]) // For SELECT type
  isRequired Boolean  @default(false)
  isActive   Boolean  @default(true)
  order      Int      @default(0)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([projectId, name])
  @@index([projectId])
}

// ============================================
// SCHEDULED REPORT & ANALYTICS
// ============================================

model ScheduledReport {
  id         Int       @id @default(autoincrement())
  projectId  Int
  name       String
  type       String // EXECUTION_SUMMARY, BUG_SUMMARY, CUSTOM
  frequency  String // DAILY, WEEKLY, MONTHLY
  recipients String[]  @default([]) // Email addresses
  isActive   Boolean   @default(true)
  lastSentAt DateTime?
  nextSendAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([projectId])
  @@index([isActive])
}

// ============================================
// ADMIN AUDIT LOG FOR CHAT CONTROLS
// ============================================

model ChatAuditLog {
  id          Int      @id @default(autoincrement())
  adminId     Int
  adminName   String   // Denormalized for readability
  actionType  String   // MESSAGE_DELETED, USER_MUTED, USER_UNMUTED, CHANNEL_LOCKED, CHANNEL_UNLOCKED, CHAT_DISABLED, CHAT_ENABLED
  targetId    Int?     // message_id, user_id, or channel_id
  targetName  String?  // For readability
  targetType  String?  // MESSAGE, USER, CHANNEL
  reason      String?  // Optional reason provided by admin
  timestamp   DateTime @default(now())
  createdAt   DateTime @default(now())

  admin User @relation("AuditLogAdmin", fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId])
  @@index([actionType])
  @@index([timestamp])
  @@index([targetId])
  @@index([targetType])
}
